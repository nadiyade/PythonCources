# Урок 33. Знакомство с Django

![](https://the-flow.ru/uploads/images/resize/830x0/adaptiveResize/06/04/56/59/17/253344b40cd7.jpg)

## Request-response, протокол http

Практически любой интернет ресурс работает на принципе **запрос-ответ**, наша задача, как програмистов, правильно описывать логику того, что должно присходить при определенном запросе. 

![](https://www.iguides.ru/upload/medialibrary/a60/a60857ccc094b4bfd975d0fa842bcb1c.png)

### Краткое описание http запросов

#### Метод GET

Используется для запроса содержимого указанного ресурса. Например получить данные, файл или любую другую информацию, браузер (Chrome, Mozzila, etc.) при наборе url (https://ru.wikipedia.org/, https://www.youtube.com/watch?v-WdZJ-QUItHw&t-7974s) использует имеено GET запрос, может передавать переменные в квери параметре (в примере с ютубом ?v-WdZJ-QUItHw&t-7974s это квери парметры, начинается с символа ?, следующий парметр добавляется при помощи символа & в данном примере, параметр {'v': 'WdZJ-QUItHw', 't': '7974s'})

Обычно не используется для отправки данных, только для получения определенной информации. Например получение коментариев к посту в блоге.

#### Метод POST

Применяется для передачи пользовательских данных заданному ресурсу. Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса. Аналогично с помощью метода POST обычно загружаются файлы на сервер. Может содержать много данных или файлов (или и то и другое).

#### Метод PUT

Применяется для обновления данных по заданному ресурсу **целиком**, например, изменение коментария. Может содержать много данных или файлов (или и то и другое).

#### Метод PATCH

Почти аналогичен методу PUT, но применяется для **частичного** изменения объекта. Допустим изменения данных в профиле в соц сети, при изменении имейла, нам не нужно изменять весь профиль, только поле имейл. Может содержать много данных или файлов (или и то и другое).

#### Метод DELETE

Используется для удаления объектов, обычно не принимает данные как и метод гет. Пример, все тот же коментарий.


Сущетвуют и другие запросы, которые используют реже и с другими назначениями, их и более подробно эти запросы, мы рассмотрим на другом занятии.

Описанные запросы используют, для стандарных CRUD операций, Create - POST, Retrieve - GET, Update - PUT/PATCH, Delete - DELETE

## Шаблон проектирования MVC

Для разработки любых сложных решений используются шаблоны проектирования.

Для нас,в данный момент, самым важных из них является **MVC (Model - View - Controller) (Модель - Отображение - Контроллер)**

Что же это такое?

Это разделение обязанностей между тремя зависимыми блоками.

Представте себе работу ресторана.
 
Моделью в таком примере является склад продуктов, на нем есть определнные продукты, но сами по себе они не меняются, без внешнего воздействия.

Отображением будет блюдо, вы как клиент (пользователь) можете прийти и заказать себе еду, но вы понятия не имеете какие именно продукты есть сейчас на складе, и можете только догадываться как именно эти продукты будут обрабатываться.

Контроллер, в этом случае, это персонал ресторана, принимают заказы, смотрят могут ли они их выполнить, обрабатывают продукты и подают за стол. и если нужно заказывают еще продукты.

![](https://miro.medium.com/max/1304/1*la8KCs0AKSzVGShoLQo2oQ.png)

По этому же принципу работает и Django, но в немного измененной, только по терминам форме, паттерн называется MVT (Model - View - Template), где View играет роль контроллера, а Template роль отображения, но суть при этом сохраняется.

## Что же такое все таки Django?

**Django** - веб-фреймворк, а фреймворк это по своей сути конструктор, который помогает нам собирать блоки, часто даже не задумываясь как именно это работает под капотом.

![](https://www.meme-arsenal.com/memes/07d78e429e60f57b09f8afb5e4446bd1.jpg)



Основной информационный ресурс [Django](https://www.djangoproject.com/)

## Наконец-то практика

Создадим новый проект, для этого, создадим новое виртуальное окружение, и установим туда Django

```python
pip install django==2.2
```

```python
django-admin startproject mysite
```

Эта команда создаёт новый проект, и заполняет его базово нужными файлами, давайте рассмотрим их.

Структура файлов:

```python
mysite/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        wsgi.py
```

**manage.py** - файл-утилка при помощи которого мы будем взаимодействовать со многими частями Django из консоли

Внитри папки mysite:

**\_\_init__.py** - Пустой файл, который говорит Python-у, что этот каталог должен рассматриваться как пакет Python-а

**settings.py** - Настройки и конфигурации проекта.

**urls.py** - URL-ы для этого проекта; «оглавление» вашего сайта на платформе Django.

**wsgi.py** - Файл отвечающий за входную точку сервера (Позволяет запускать код как сайт)

Проверим работоспособность.

В консоли запустим локальный "сервер" из папки с нашим "сайтом" (в моём примере mysite)

```python
python manage.py runserver
```

В консоли должна появиться примерно такая надпись.

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson33/runserver.png)


Не закрывая консоль (сервер должен работать), открываем в браузере http://127.0.0.1:8000/

127.0.0.1  это локальный хост а :8000 это номер порта на котором запущен процесс.
127.0.0.1 можно заменить на 0.0.0.0 или слово localhost, все три варианта взаимозаменяемы.

Если вы всё сделали правильно, то в бразузере должны увидете, что то такое:

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson33/worked.png)

## Создаём приложение

Настройки и конфигурации это замечательно, но правильная архитектура приложения, подразумевает использование отдельных модулей как части сайта (бывает один на весь сайт, а бывают и тысячи), такие модули называются приложениями, и именно в них пишется "суть" сайта.

Через консоль, и уже известную нам `manage.py` создадим приложение

```python
python manage.py startapp myapp
```

Команда создаст вам папку с вашим приложением, давайте разберем её подробнее

```python
myapp/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py
```

**\_\_init__.py** - Пустой файл, который говорит Python-у, что этот каталог должен рассматриваться как пакет Python-а

**admin.py** - заготовка под админку

**apps.py** - информация о приложении (нужно при большом коле-ве приложений, для удобства)

**папка migrations** - Тут будут миграции базы данных.

**models.py** - Модели.

**tests.py** - Тесты.

**views.py** - Контроллер приложения.

## Создадим первые URL-ы

Для начала изменим файл `views.py`

```python
from django.http import HttpResponse


def first(request):
    return HttpResponse("Hey! It's your first view!!")
```

Для работы нашего приложения, создаём дополнительный файл в папке с приложением и назовем его `urls.py`

`myapp/urls.py`

```python
from django.urls import path

from .views import first

urlpatterns = [
    path('', first, name='index'),
]
```

В файле с урлами создадим ссылку на урлы приложения

`mysite/urls.py`

```python
from django.urls import include, path

urlpatterns = [
    path('my_url/', include('myapp.urls')),
]
```

Теперь откроем наш "сайт" и введем в адресную строку http://127.0.0.1:8000/my_url/

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson33/first_view.png)


Роутинг можно строить так как вам удобно, или как того требует задание.

Напишем еще один путь, для "главной" страницы. В файле `myapp/views.py`

```python
def index(request):
    return HttpResponse("It's index page!!")
```

А в файле `mysite/urls.py` импортируем эту функции и добавим маршрут в список, что бы получилось так:

```python
from django.urls import include, path
from myapp.views import index

urlpatterns = [
    path('my_url/', include('myapp.urls')),
    path('', index, name='index')
]
```

Открываем главную страницу и видим результат.

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson33/index.png)


### Урлы с параметрами

Урл может заведомо принимать параметры, самый простой способ, это описание парметра через синтаксис `<type:variable>`

Обновим наш `urls.py`:

```python
from django.urls import include, path
from myapp.views import index, main_article, uniq_article, article

urlpatterns = [
    path('my_url/', include('myapp.urls')),
    path('', index, name='index'),
    path('article/', main_article, name='mail_article'),
    path('article/33/', uniq_article, name='uniq_article'),
    path('article/<int:article_id>/', article, name='article'),
    path('article/<int:article_id>/<slug:name>', article, name='article_name'),
]
```

И добавим к  `myapp/views.py`:

```python
def main_article(request):
    return HttpResponse('There will be a list with articles')


def uniq_article(request):
    return HttpResponse('This is uniq answer for uniq value')


def article(request, article_id, name=''):
    return HttpResponse(
        "This is an article #{}. {}".format(article_id, "Name of this article is {}".format(
            name) if name else "This is unnamed article"))
```

Давайте разбереме подробнее.

Мы описали два статических урла `article/` и `article/33`

и два динамических `article/<int:article_id>/` и `article/<int:article_id>/<slug:name>` 
причём в качестве обработика динамических урлов, мы указали одну и туже функцию `article`, в которой указали что будет приниматься два параметра `article_id` и `name`, и при этом `name` не является обязательным, т.к. имеет значение по умолчанию.

Давайте посмотрим на результат.

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson33/static_url.png)

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson33/static_const_url.png)

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson33/dinamic_without_name.png)

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson33/dinamic_with_name.png)

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson33/wrong_url.png)

Последнее это пример работы если урл не был описан (Всем известная страница 404, в дебаг режиме, она может рассказать много подробностей об ошибке)


## Обработка кастомных случаев

Бывают варианты, когда нужно применять более сложные структуры урлов, и для их обработки нам поможет огромное кол-во вспомогательных методов и классом, или регулярные выражения.

Рассмотрите их самостоятельно по [Вот Этой Ссылке](https://docs.djangoproject.com/en/2.2/topics/http/urls/)


# Домашнее задание:

1. Создать новый прокт и новое приложение

2. Создать в нём всю необходимую структуру, для урлов `http://127.0.0.1:8000/`, `http://127.0.0.1:8000/acricles`, `http://127.0.0.1:8000/acrticles/archive`, `http://127.0.0.1:8000/users`

3. Создать структуру для динамических урлов: `http://127.0.0.1:8000/article/<int:article_number>`, `http://127.0.0.1:8000/http://127.0.0.1:8000/article/<int:article_number>/archive` и `http://127.0.0.1:8000/users/<int:user_number>`

Возвращать урлы, могут, всё что угодно, главное, что бы они работали!!!
